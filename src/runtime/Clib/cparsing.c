/* The PDA automaton for parsers generated by camlyacc */

#include <bigloo.h>
#include "Clib/value-bigloo.h"
#include "Clib/mlvalues.h"

#if defined(ANSI) || defined(SIGNED_CHAR_WORKS) || defined( __STDC__ )
typedef signed char schar;
#else
typedef char schar;
#endif 

struct parser_tables {    /* Mirrors parse_tables in ../lib/parsing.mli */
	header_t        header;   
	union object   *length;
	value actions;
	value transl;
	char * lhs;
	char * len;
	char * defred;
	char * dgoto;
	char * sindex;
	char * rindex;
	char * gindex;
	value tablesize;
	char * table;
	char * check;
}; 

struct parser_env {       /* Mirrors parser_env in ../lib/iparsing.mli */
	header_t        header;   
	union object   *length;
	value s_stack;
	value v_stack;
	value symb_start_stack;
	value symb_end_stack;
	value stacksize;
	value curr_char;
	value lval;
	value symb_start;
	value symb_end;
	value sp;
	value rule_len;
	value rule_number;
};

#ifdef BIG_ENDIAN
#define Short(tbl,n)								  \
  (*((unsigned char *)((BSTRING_TO_STRING(tbl)) + (n) * sizeof(short))) + \
   (*((schar *)((BSTRING_TO_STRING(tbl)) + (n) * sizeof(short) + 1)) << 8))
#else
#ifdef LITTLE_ENDIAN
#define Short(tbl,n) (((short *)(BSTRING_TO_STRING(tbl)))[n])
#else
--> error "I need to know if this machine is `little' or `big' endian !"
#endif
#endif

#ifdef DEBUG
int parser_trace = 1;
#define Trace(act) if(parser_trace) act 
#else
#define Trace(act)
#endif

/* Input codes */

#define START 0            /* Mirrors parser_input in ../lib/iparsing.mli */
#define TOKEN_READ 1
#define STACKS_GROWN_1 2
#define STACKS_GROWN_2 3
#define SEMANTIC_ACTION_COMPUTED 4

/* Output codes */

#define READ_TOKEN Atom(0) /* Mirrors parser_output in ../lib/iparsing.mli */
#define RAISE_PARSE_ERROR Atom(1)
#define GROW_STACKS_1 Atom(2)
#define GROW_STACKS_2 Atom(3)
#define COMPUTE_SEMANTIC_ACTION Atom(4)

/* The pushdown automata */

value parse_engine(tables, env, cmd, arg) /* ML */
     struct parser_tables * tables;
     struct parser_env * env;
     value cmd;
     value arg;
{
  static int state;
  static mlsize_t sp;
  int n, n1, n2, m, state1;

  Trace(puts( "parse_engine: " ));
  Trace(dprint( cmd ) );
  Trace(dprint( arg ) );
  
  switch(Tag_of_val(cmd)) {

  case START:
    Trace(printf("START\n"));
	state = 0;
    sp = Int_of_val(env->sp);

  loop:
    Trace(printf("Loop %d\n", state));
	//n = Short(BSTRING_TO_STRING( tables->defred ), state);
	//n = Short(tables->defred[state]);
	n = Short(tables->defred, state);
	Trace(printf( "n: %d\n", n ));
    if (n != 0) goto reduce;
    if (Int_of_val(env->curr_char) >= 0) goto testshift;
    return READ_TOKEN;
                                /* The ML code calls the lexer and updates */
                                /* symb_start and symb_end */
  case TOKEN_READ:

	Trace( printf( "TOKEN_READ      : %d\n",  Tag_of_val(arg) ) );
	Trace( printf( "                : %d\n",  arg ) );
	Trace( dprint( arg ) );
	 
    env->curr_char = Field(tables->transl, Tag_of_val(arg));
	 
	Trace(printf( "  env->curr_char: %d\n", env->curr_char ));
	Trace(printf( "  Wosize_val    : %d\n", Wosize_val(arg) ));

    if (Wosize_val(arg) == 0) {
      env->lval = Val_of_long(0);
    } else {
	  Trace(printf( "  Field         : %d\n", Field(arg, 0) ));
      env->lval = Field(arg, 0);
    }
    Trace(printf("Token %d (0x%lx)\n", Int_of_val(env->curr_char), env->lval));
    
  testshift:
	Trace(printf("testshift %d\n", n));
	//n1 = Short(BSTRING_TO_STRING( tables->sindex ), state);
	//n1 = Short(tables->sindex[state]);
	n1 = Short(tables->sindex, state);
    n2 = n1 + Int_of_val(env->curr_char);
	Trace(printf("Dans testshift: n1:%d  n2:%d  v1: %d  v2:%d  v3:%d\n",
				 n1,n2, (Int_of_val(tables->tablesize)),
				 //Short(BSTRING_TO_STRING( tables->check ), n2),
				 //Short(tables->check[n2]),
				 Short(tables->check, n2),
				 Int_of_val(env->curr_char) ) );

    if (n1 != 0 && n2 >= 0 && n2 <= Int_of_val(tables->tablesize) &&
		//Short(BSTRING_TO_STRING( tables->check ), n2) == Int_of_val(env->curr_char)
		//Short(tables->check[n2] == Int_of_val(env->curr_char))
		Short(tables->check, n2) == Int_of_val(env->curr_char)
		) goto shift;
    //n1 = Short(BSTRING_TO_STRING( tables->rindex ), state);
	//n1 = Short(tables->rindex[state]);
	n1 = Short(tables->rindex, state);
    n2 = n1 + Int_of_val(env->curr_char);
	Trace(printf("Dans testshift: n1: %d   n2: %d  state1: %d  sp:%d\n",
				 n1,n2, state1, sp ) );
    if (n1 != 0 && n2 >= 0 && n2 <= Int_of_val(tables->tablesize) &&
        //Short(BSTRING_TO_STRING( tables->check ), n2) == Int_of_val(env->curr_char)
		//Short(tables->check[n2] == Int_of_val(env->curr_char))
		Short(tables->check, n2) == Int_of_val(env->curr_char)
		) {
      //n = Short(BSTRING_TO_STRING( tables->table ), n2);
	  //n = Short(tables->table[n2]);
	  n = Short(tables->table, n2);
      goto reduce;
    }
	Trace(puts( "RAISE_PARSE_ERROR" ) );
    return RAISE_PARSE_ERROR;
                                /* The ML code raises the Parse_error exn */

  shift:
    //state = Short(BSTRING_TO_STRING( tables->table ), n2);
	//state = Short(tables->table[n2]);
	state = Short(tables->table, n2);
    Trace(printf("Shift %d\n", state));
    sp++;
    if (sp < Long_of_val(env->stacksize)) goto push;
    return GROW_STACKS_1;
                                /* The ML code resizes the stacks */

  case STACKS_GROWN_1:
    Trace(printf("STACKS_GROWN_1\n"));

  push:
	/*     Field(env->s_stack, sp) = Val_of_int(state);                       */
	/*      modify(&(Field(env->v_stack, sp)), env->lval);                 */
	/*     Field(env->symb_start_stack, sp) = env->symb_start;             */
	/*     Field(env->symb_end_stack, sp) = env->symb_end;                 */
    Trace(printf("Push %d\n", state));
	FieldSet(env->s_stack, sp, Val_of_int(state) );
	FieldSet(env->v_stack, sp, env->lval);
	FieldSet(env->symb_start_stack, sp, env->symb_start);
	FieldSet(env->symb_end_stack, sp, env->symb_end);
    env->curr_char = Val_of_int(-1);
    goto loop;
	
  reduce:
    Trace(printf("Reduce %d\n", n));
    //m = Short(BSTRING_TO_STRING( tables->len ), n);
	//m = Short(tables->len[n]);
	m = Short(tables->len, n);
    env->sp = Val_of_int(sp);
    env->rule_number = Val_of_int(n);
    env->rule_len = Val_of_int(m);
    sp = sp - m + 1;
    //m = Short(BSTRING_TO_STRING( tables->lhs) , n);
	//m = Short(tables->lhs[n]);
	m = Short(tables->lhs, n);
    state1 = Int_of_val(Field(env->s_stack, sp - 1));
    //n1 = Short(BSTRING_TO_STRING( tables->gindex ), m);
	//n1 = Short(tables->gindex[m]);
	n1 = Short(tables->gindex, m);
    n2 = n1 + state1; 
	Trace(printf("Dans reduce: n1: %d   n2: %d  m:%d  state1: %d  sp:%d\n",
				 n1,n2, m, state1, sp ) );
    if (n1 != 0 && n2 >= 0 && n2 <= Int_of_val(tables->tablesize) &&
        //Short(BSTRING_TO_STRING( tables->check ), n2) == state1
		//Short(tables->check[n2] == state1)
		Short(tables->check, n2) == state1
		) {
      //state = Short(BSTRING_TO_STRING( tables->table ), n2);
	  //state = Short(tables->table[n2]);
	  state = Short(tables->table, n2);
    } else {
      //state = Short(BSTRING_TO_STRING( tables->dgoto ), m);
	  //state = Short(tables->dgoto[m]);
	  state = Short(tables->dgoto, m);
    }
    if (sp < Long_of_val(env->stacksize)) goto semantic_action;
    return GROW_STACKS_2;
	                                 /* The ML code resizes the stacks */

  case STACKS_GROWN_2:
    Trace(printf("STACKS_GROWN_2\n"));

  semantic_action:
	Trace(printf("semantic_action:\n"));
    return COMPUTE_SEMANTIC_ACTION;
                                /* The ML code calls the semantic action */

  case SEMANTIC_ACTION_COMPUTED:
    Trace(printf("SEMANTIC_ACTION_COMPUTED\n"));
	/*     Field(env->s_stack, sp) = Val_int(state);                       */
	/*     modify(&Field(env->v_stack, sp), arg);                          */
	/*     Field(env->symb_end_stack, sp) = Field(env->symb_end_stack, Int_of_val(env->sp)); */
	FieldSet(env->s_stack, sp, Val_of_int(state));
    FieldSet(env->v_stack, sp, arg);
    FieldSet(env->symb_end_stack, sp, Field(env->symb_end_stack, Int_of_val(env->sp)));
    goto loop;
  }
}
